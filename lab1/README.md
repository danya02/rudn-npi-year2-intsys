# Отчет по лабораторной работе 1
## Генералов Даниил, НПИ-01-21, 1032212280

В рамках этой лабораторной работы требовалось реализовать алгоритмы поиска по карте: A*, Dijkstra и BFS.
Я успешно реализовал эти алгоритмы и проверил их работу на картах-примерах.
Я также сделал проверку скорости работы этих алгоритмов и проанализировал результаты.

### Дизайн программы

Информацию о карте содержит класс `GraphAccessor`.
Он хранит в себе множество вершин, которые являются препятствиями,
и предоставляет методы по поиску соседей вершины.
Внутри него находятся все настройки карты -- размер, начальная и конечная вершины, алгоритм поиска и т.д.

Он также содержит в себе переменную информацию: списки *OPEN* и *CLOSED*, текущие *g*-значения,
предыдущие вершины и т.д.
Это сделано так, чтобы можно было менять лежащие в основе этого структуры данных;
изначально использовалась база данных SQLite для хранения всей информации, в том числе переменной,
и когда я осознал, что это слишком медленно, я переписал это на использование обычных структур данных,
и это не изменило внешний API класса.
(Это изменение уже произошло раньше, когда идентификаторы вершин сменились на их координаты.)

Алгоритмы поиска реализованы с помощью отдельных функций, которые принимают на вход `GraphAccessor` и
работают с ним.
Эти функции -- `run_astar_search`, `run_bfs` и `reconstruct_path`.
(Функции `run_dijkstra_search` не существует; алгоритм Дейкстры является частным случаем A*,
когда эвристика равна нулю.
Поэтому я просто вызываю `run_astar_search`, предварительно установив вес эвристики в ноль -- 
для этого случая есть оптимизация в `GraphAccessor.get_open_node_with_lowest_value`.)

Функции `run_astar` и `run_bfs` используют `expand_node` для раскрытия вершины.
Более того, эти две функции идентичны, за исключением того как они выбирают следующую вершину для раскрытия:
`run_bfs` выбирает `GraphAccessor.open_nodes.first()`, значение которого не определено, а `run_astar` выбирает вершину с наименьшим значением эвристики.

Функция `expand_node` принимает на вход вершину, которую нужно раскрыть, и раскрывает её.
Для этого `GraphAccessor` предоставляет список соседей этой вершины (в которые можно пройти),
и для каждой проверяется, лучше проходить через раскрываемую вершину или нет.
Это записывается в `GraphAccessor` с помощью соответствующих методов,
а затем вершина добавляется в `GraphAccessor.closed_nodes`.

Функция `reconstruct_path` принимает на вход конечную вершину и возвращает список вершин, которые нужно пройти,
чтобы добраться до неё.
Это делается путём обратного прохода по `GraphAccessor` от конечной вершины до начальной.
Эта функция иногда возвращает список, содержащий только конечную вершину, если путь не найден.
Ситуацию, когда путь не найден, можно обнаружить, если конечной вершины нет в `GraphAccessor.closed_nodes`,
или если ее нет в `GraphAccessor.came_from`, или если расстояние до нее равно максимальному значению
(для `double` это значение отображается как `1.79769e+308`).

Примеры карт, которые были нам предоставлены, были в формате XML.
Поскольку я раньше использовал SQLite, чтобы хранить данные, я написал скрипт на Python,
которые конвертируют XML в SQLite.
Позднее переход на простые структуры данных заставил меня написать второй скрипт,
который конвертирует SQLite в плоский текстовый файл.
Некоторые бы сказали, что лучше было бы сразу использовать XML из C-кода,
и возможно они были бы правы.


### Измерение производительности

Функция `main` запускает нужный алгоритм поиска пути и выводит результат.
Помимо этого, на Linux-системах предпринимаются дополнительные шаги,
чтобы измерение скорости работы алгоритма было более точным.
Во-первых, с помощью `sched_setaffinity` процесс привязывается к первому ядру процессора,
чтобы переключения между ядрами не замедляли измерение.
Во-вторых, процессу задается максимальный приоритет с помощью `setpriority` --
это не всегда возможно сделать (например, если запуск происходит от имени не-администратора),
но в этом случае программа продолжает работать, выводя debug-сообщение.

Все эти предосторожности нужны, потому что измерение времени работы алгоритма
производится по циклам процессора.
Для этого используется инструкция Intel `rdtsc`, которая возвращает значение счетчика циклов процессора.
Это значение -- самый точный способ измерить время работы кода, но при этом измерения будет искажать то,
что происходит в других процессах, в том числе в других ядрах процессора.
В частности, все измерения производились на моем ноутбуке,
на котором я также пишу этот текст и который также записывает видео с экрана.
Поэтому процессор будет делать много других вещей, кроме моего кода,
и нет способа выполнять мой код монопольно.

Учитывая это, я также измеряю гораздо менее точную метрику -- количество секунд на часах,
которое прошло между запуском и завершением всей программы.
Это значение можно использовать только для сравнения между собой,
и даже в этом случае неполностью из-за разных технических факторов.
Единственная польза этой метрики -- поскольку она в секундах, то она легко читается человеком,
в отличии от количества циклов процессора, которое гораздо труднее интерпретировать.

### Анализ производительности

Для того, чтобы автоматически снимать измерения, я написал программу `benchmark_execution.py`,
которая запускает одну и ту же карту с разными алгоритмами и параметрами.
Для каждой конфигурации выполняется 10 запусков, и статистика по каждому из них собирается
и выводится в файл `results.csv`.
Поля в этом файле, по порядку: название карты, название алгоритма, метрика для эвристики A*, вес эвристики,
степень связности (4 или 8), количество циклов процессора, количество сконструированых структур для вершин,
количество раскрытых вершин, общий вес пути, количество секунд на часах.
Его полное содержимое приложено в репозитории рядом с этим отчетом.
(Для оптимизации сделано так, что когда алгоритм не A*, то вес эвристики задается как 0 --
это значит, что программа не запускается больше чем 10 раз, когда алгоритм не использует эвристику.
Я слишком поздно осознал, что можно было бы также пропускать перебор метрик, 
когда алгоритм не A* -- но зато теперь есть больше данных по запускам этих других алгоритмов.)

Интересные результаты:

- Используя линейную регрессию количества циклов против времени работы, можно заметить, что в одну секунду производится 2802646516 циклов процессора на моем компьютере. Это соответствует частоте 2.8 ГГц, обозначенной в спецификации процессора. Таким образом, можно сделать вывод, что программа работает с максимальной возможной производительностью.
- Средняя длина пути по всем картам с 4мя соседями составляет 78 ячеек, а с 8 -- 66.98. Это значит, что возможность двигаться по диагонали уменьшает длину пути в среднем на 15%.
- Каждую конфигурацию я тестировал 10 раз, чтобы выровнять случайные изменения. В среднем разница между минимальным и максимальным количеством используемых циклов составила 1,150,000,000, или примерно 500 мс. Самая большая разница была в 75,900,000,000 циклов, или 27 секунд -- это наверняка связано с переключением режимов энергосбережения процессора, потому что компьютер выключил монитор во время тестирования.
- Для каждой из карт и одинаковой смежности минимальная длина пути всегда одинаковая, что говорит о том, что эти алгоритмы реализованы верно.
- Внутри одной карты, количество вершин, которые были раскрыты алгоритмом A*, очень зависит от веса эвристики и от смежности. Например, на карте 0:

| Смежность | Вес эвристики | Количество вершин | Длина пути |
|-----------|---------------|-------------------|------------|
| 4         | 0.5           | 2930              | 114        |
| 8         | 0.5           | 2930              | 89.56      |
| 4         | 1.0           | 2930              | 114        |
| 8         | 1.0           | 2931              | 89.56      |
| 4         | 2.0           | 3575              | 114        |
| 8         | 2.0           | 13870             | 89.56      |
| 4         | 10.0          | 17674             | 114        |
| 8         | 10.0          | 64080             | 89.56      |

- Карта 3 не имеет пути, потому что стартовая и конечная точка находятся в стене. Поэтому все алгоритмы завершаются гораздо быстрее, чем на других картах -- в среднем за 140,000 циклов. 
- Больше всего времени потребовалось на поиск пути на самой большой карте (карта 4), с 8-меричной связностью, с мэнхэттенской или эвклидовой эвристикой и весом 10. В среднем поиск происходил за 370,000,000,000 циклов, или около 130 секунд. Это можно обьяснить тем, что алгоритм много времени пытался идти прямо к выходу, но между стартом и выходом было много стен, поэтому он тратил много времени раскрывая вершины, которые линейно близко к выходу, но в которые пройти нельзя, поэтому рассматривать их не нужно.
- Меньше всего времени (за исключением карты 3) потребовалось на поиск пути на карте 5 с алгоритмом BFS и 4-мерной связностью -- за 13,100,000 циклов. Это потому, что между первой и последней ячейкой нет стен и путь почти прямой. Но при этом это даже быстрее, чем алгоритм A*, который делает шаги прямо к цели, потому что для того чтобы это сделать необходимо сканировать список *OPEN*, а это дорогое действие -- алгоритм BFS не делает этого, а просто выбирает первую вершину из списка *OPEN* и раскрывает её, что получается значительно быстрее.